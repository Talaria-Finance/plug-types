// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.19;

/**
 * @title Framework:ITypes
 * @notice The base EIP-712 types that power a modern intent framework.
 * @dev This file was auto-generated by @nftchance/emporium-types/cli.
 *      (https://github.com/nftchance/emporium-types)
 * @dev This interface and the consuming abstract are auto-generated by
 *      types declared in the framework configuration. As an extensible
 *      base, all projects build on top of Delegations and Invocations.
 * @author @nftchance
 * @author @danfinlay (https://github.com/delegatable/delegatable-sol)
 */
interface ITypes {
	/**
     * @notice The Delegation struct is auto-generated and should not be edited.
     * @dev This struct is used to encode Delegation data into a packet hash and
     *      decode Delegation data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'delegate', type: 'address' }
	 *    { name: 'authority', type: 'bytes32' }
	 *    { name: 'caveats', type: 'Caveat[]' }
     * }>
     */
    struct Delegation {
		address delegate;
		bytes32 authority;
		Caveat[] caveats;
	}

	/**
     * @notice The Caveat struct is auto-generated and should not be edited.
     * @dev This struct is used to encode Caveat data into a packet hash and
     *      decode Caveat data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'enforcer', type: 'address' }
	 *    { name: 'terms', type: 'bytes' }
     * }>
     */
    struct Caveat {
		address enforcer;
		bytes terms;
	}

	/**
     * @notice The Transaction struct is auto-generated and should not be edited.
     * @dev This struct is used to encode Transaction data into a packet hash and
     *      decode Transaction data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'to', type: 'address' }
	 *    { name: 'gasLimit', type: 'uint256' }
	 *    { name: 'data', type: 'bytes' }
     * }>
     */
    struct Transaction {
		address to;
		uint256 gasLimit;
		bytes data;
	}

	/**
     * @notice The SignedDelegation struct is auto-generated and should not be edited.
     * @dev This struct is used to encode SignedDelegation data into a packet hash and
     *      decode SignedDelegation data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'delegation', type: 'Delegation' }
	 *    { name: 'signature', type: 'bytes' }
	 *    { name: 'signerIsContract', type: 'bool' }
     * }>
     */
    struct SignedDelegation {
		Delegation delegation;
		bytes signature;
		bool signerIsContract;
	}

	/**
     * @notice The Invocation struct is auto-generated and should not be edited.
     * @dev This struct is used to encode Invocation data into a packet hash and
     *      decode Invocation data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'transaction', type: 'Transaction' }
	 *    { name: 'authority', type: 'SignedDelegation[]' }
     * }>
     */
    struct Invocation {
		Transaction transaction;
		SignedDelegation[] authority;
	}

	/**
     * @notice The ReplayProtection struct is auto-generated and should not be edited.
     * @dev This struct is used to encode ReplayProtection data into a packet hash and
     *      decode ReplayProtection data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'nonce', type: 'uint256' }
	 *    { name: 'queue', type: 'uint256' }
     * }>
     */
    struct ReplayProtection {
		uint256 nonce;
		uint256 queue;
	}

	/**
     * @notice The Invocations struct is auto-generated and should not be edited.
     * @dev This struct is used to encode Invocations data into a packet hash and
     *      decode Invocations data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'batch', type: 'Invocation[]' }
	 *    { name: 'replayProtection', type: 'ReplayProtection' }
     * }>
     */
    struct Invocations {
		Invocation[] batch;
		ReplayProtection replayProtection;
	}
}

/**
 * @title Framework:Types 
 * @dev This file was auto-generated by @nftchance/emporium-types/cli.
 *      (https://github.com/nftchance/emporium-types)
 * @dev This abstract contract is auto-generated and should not be edited directly
 *      however it should be directly inherited from in the consuming protocol.
 * @author @nftchance
 * @author @danfinlay (https://github.com/delegatable/delegatable-sol)
 */
abstract contract Types is ITypes {
	bytes32 constant DELEGATION_TYPEHASH = keccak256('');

	bytes32 constant CAVEAT_TYPEHASH = keccak256('');

	bytes32 constant TRANSACTION_TYPEHASH = keccak256('');

	bytes32 constant SIGNEDDELEGATION_TYPEHASH = keccak256('');

	bytes32 constant INVOCATION_TYPEHASH = keccak256('');

	bytes32 constant REPLAYPROTECTION_TYPEHASH = keccak256('');

	bytes32 constant INVOCATIONS_TYPEHASH = keccak256('');

	/**
    * @notice GET_DELEGATION_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode Delegation data into a packet hash and
    *      decode Delegation data from a packet hash.
    * @param $input The Delegation data to encode.
    * @return $hash The packet hash of the encoded Delegation data.
    */
    function GET_DELEGATION_PACKETHASH (
        Delegation memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        $hash = keccak256(abi.encode(
            DELEGATION_TYPEHASH,
            $input.delegate,
			$input.authority,
			GET_CAVEAT_ARRAY_PACKETHASH($input.caveats)
        ));
    }

	/**
    * @notice GET_CAVEAT_ARRAY_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode Caveat[] data into a packet hash and
    *      decode Caveat[] data from a packet hash.
    * @param $input The Caveat[] data to encode. 
    * @return $hash The packet hash of the encoded Caveat[] data.
    */
    function GET_CAVEAT_ARRAY_PACKETHASH (
        Caveat[] memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        bytes memory encoded;

        uint256 i;
        uint256 length = $input.length;

        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                GET_CAVEAT_PACKETHASH($input[i])
            );

            unchecked { i++; }
        }
        
        $hash = keccak256(encoded);
    }
	/**
    * @notice GET_CAVEAT_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode Caveat data into a packet hash and
    *      decode Caveat data from a packet hash.
    * @param $input The Caveat data to encode.
    * @return $hash The packet hash of the encoded Caveat data.
    */
    function GET_CAVEAT_PACKETHASH (
        Caveat memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        $hash = keccak256(abi.encode(
            CAVEAT_TYPEHASH,
            $input.enforcer,
			keccak256($input.terms)
        ));
    }

	/**
    * @notice GET_TRANSACTION_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode Transaction data into a packet hash and
    *      decode Transaction data from a packet hash.
    * @param $input The Transaction data to encode.
    * @return $hash The packet hash of the encoded Transaction data.
    */
    function GET_TRANSACTION_PACKETHASH (
        Transaction memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        $hash = keccak256(abi.encode(
            TRANSACTION_TYPEHASH,
            $input.to,
			$input.gasLimit,
			keccak256($input.data)
        ));
    }

	/**
    * @notice GET_SIGNEDDELEGATION_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode SignedDelegation data into a packet hash and
    *      decode SignedDelegation data from a packet hash.
    * @param $input The SignedDelegation data to encode.
    * @return $hash The packet hash of the encoded SignedDelegation data.
    */
    function GET_SIGNEDDELEGATION_PACKETHASH (
        SignedDelegation memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        $hash = keccak256(abi.encode(
            SIGNEDDELEGATION_TYPEHASH,
            GET_DELEGATION_PACKETHASH($input.delegation),
			keccak256($input.signature),
			$input.signerIsContract
        ));
    }

	/**
    * @notice GET_INVOCATION_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode Invocation data into a packet hash and
    *      decode Invocation data from a packet hash.
    * @param $input The Invocation data to encode.
    * @return $hash The packet hash of the encoded Invocation data.
    */
    function GET_INVOCATION_PACKETHASH (
        Invocation memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        $hash = keccak256(abi.encode(
            INVOCATION_TYPEHASH,
            GET_TRANSACTION_PACKETHASH($input.transaction),
			GET_SIGNEDDELEGATION_ARRAY_PACKETHASH($input.authority)
        ));
    }

	/**
    * @notice GET_SIGNEDDELEGATION_ARRAY_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode SignedDelegation[] data into a packet hash and
    *      decode SignedDelegation[] data from a packet hash.
    * @param $input The SignedDelegation[] data to encode. 
    * @return $hash The packet hash of the encoded SignedDelegation[] data.
    */
    function GET_SIGNEDDELEGATION_ARRAY_PACKETHASH (
        SignedDelegation[] memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        bytes memory encoded;

        uint256 i;
        uint256 length = $input.length;

        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                GET_SIGNEDDELEGATION_PACKETHASH($input[i])
            );

            unchecked { i++; }
        }
        
        $hash = keccak256(encoded);
    }
	/**
    * @notice GET_REPLAYPROTECTION_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode ReplayProtection data into a packet hash and
    *      decode ReplayProtection data from a packet hash.
    * @param $input The ReplayProtection data to encode.
    * @return $hash The packet hash of the encoded ReplayProtection data.
    */
    function GET_REPLAYPROTECTION_PACKETHASH (
        ReplayProtection memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        $hash = keccak256(abi.encode(
            REPLAYPROTECTION_TYPEHASH,
            $input.nonce,
			$input.queue
        ));
    }

	/**
    * @notice GET_INVOCATIONS_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode Invocations data into a packet hash and
    *      decode Invocations data from a packet hash.
    * @param $input The Invocations data to encode.
    * @return $hash The packet hash of the encoded Invocations data.
    */
    function GET_INVOCATIONS_PACKETHASH (
        Invocations memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        $hash = keccak256(abi.encode(
            INVOCATIONS_TYPEHASH,
            GET_INVOCATION_ARRAY_PACKETHASH($input.batch),
			GET_REPLAYPROTECTION_PACKETHASH($input.replayProtection)
        ));
    }

	/**
    * @notice GET_INVOCATION_ARRAY_PACKETHASH() is auto-generated and should not be edited.
    * @dev This function is used to encode Invocation[] data into a packet hash and
    *      decode Invocation[] data from a packet hash.
    * @param $input The Invocation[] data to encode. 
    * @return $hash The packet hash of the encoded Invocation[] data.
    */
    function GET_INVOCATION_ARRAY_PACKETHASH (
        Invocation[] memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        bytes memory encoded;

        uint256 i;
        uint256 length = $input.length;

        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                GET_INVOCATION_PACKETHASH($input[i])
            );

            unchecked { i++; }
        }
        
        $hash = keccak256(encoded);
    }
}